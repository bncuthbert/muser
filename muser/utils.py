""" Utility functions. """

import numpy as np
import peakutils
import functools
import time

def wait_while(toggle_attr):
    """Returns a decorator that waits for an instance attribute to be false."""
    def wait_while_decorator(instance_method):
        """Waits on a toggle attribute before executing an instance method."""
        @functools.wraps(instance_method)
        def wrapper(self, *args, **kwargs):
            while getattr(self, toggle_attr):
                pass
            return instance_method(self, *args, **kwargs)

        return wrapper
    return wait_while_decorator


def set_true(toggle_attr):
    """Returns a decorator that enables an attribute during execution."""
    def set_true_decorator(instance_method):
        """Enables a boolean attribute while the decorated method executes."""
        @functools.wraps(instance_method)
        def wrapper(self, *args, **kwargs):
            setattr(self, toggle_attr, True)
            output = instance_method(self, *args, **kwargs)
            setattr(self, toggle_attr, False)
            return output

        return wrapper
    return set_true_decorator


def if_true(toggle_attr):
    """Returns a decorator that executes a method if a condition is met."""
    def if_true_decorator(instance_method):
        """Execute the decorated method conditional on a toggle attribute."""
        @functools.wraps(instance_method)
        def wrapper(self, *args, **kwargs):
            if getattr(self, toggle_attr):
                return instance_method(self, *args, **kwargs)

        return wrapper
    return if_true_decorator


def record_timepoints(timepoints_list_attr):
    def record_timepoints_decorator(instance_method):
        @functools.wraps(instance_method)
        def wrapper(self, *args, **kwargs):
            start = time.time()
            output = instance_method(self, *args, **kwargs)
            stop = time.time()
            getattr(self, timepoints_list_attr).append((start, stop))
            return output

        return wrapper
    return record_timepoints_decorator


def get_peaks(y, x, thres):
    """Return the peaks in data that exceed a relative threshold."""
    try:
        peaks_idx = [peakutils.indexes(ch, thres=thres) for ch in y]
        # TODO: could convert to numpy (constant size) if assign peaks
        #       to harmonic object containing all notes
        #       (could also be used for training)
        peaks = [(x[idx], y[i][idx]) for i, idx in enumerate(peaks_idx)]
    except TypeError:  # amp not iterable
        return get_peaks([y], x, thres=thres)

    return peaks


def nearest_pow(num, base, rule=round):
    """Given a base, return power nearest to num.

    Parameters:
        num (float):
        base (float):
        rule (function):
    """
    return int(rule(np.log10(num) / np.log10(base)))


def lmap(*args):
    return list(map(*args))


def series(func, length, *args):
    return lmap(func, args * length)


def get_batches(get_member, batches, batch_size, member_args=(None,)):
    """Return batches of elements generated by `get_member`.

    Parameters:
        get_member (function): Generates batch members
        batches (int): Number of batches to return
        batch_size (int): Number of members in each batch
        member_args (iterable): Parameters to pass to `get_member`

    Returns:
        batches (list): A series of batches from `get_member`
    """
    def batch(*args):
        return series(get_member, batch_size, *args)
    batches = series(batch, batches, *member_args)
    return batches
