""" Utility functions. """

import numpy as np
import peakutils
import functools


def wait(lock_attr):
    """Returns a decorator that waits for a ``False`` instance attribute."""
    def wait_decorator(func):
        """Waits on a lock attribute before executing an instance method."""
        @functools.wraps(func)
        def wrapper(self, *args, **kwargs):
            while getattr(self, lock_attr):
                pass
            return func(self, *args, **kwargs)

        return wrapper
    return wait_decorator


def get_peaks(amp, frq, thres):
    """ """
    try:
        peaks_idx = [peakutils.indexes(ch, thres=thres) for ch in amp]
        # TODO: could convert to numpy (constant size) if assign peaks
        #       to harmonic object containing all notes
        #       (could also be used for training)
        peaks = [(frq[idx], amp[i][idx]) for i, idx in enumerate(peaks_idx)]
    except TypeError:  # amp not iterable
        return get_peaks([amp], frq, thres=thres)

    return peaks


def nearest_pow(num, base, rule=round):
    """Given a base, return power nearest to num.

    Parameters:
        num (float):
        base (float):
        rule (function):
    """
    return int(rule(np.log10(num) / np.log10(base)))


def lmap(*args):
    return list(map(*args))


def series(func, length, *args):
    return lmap(func, args * length)


def get_batches(get_member, batches, batch_size, member_args=(None,)):
    """Return batches of elements generated by `get_member`.

    Parameters:
        get_member (function): Generates batch members
        batches (int): Number of batches to return
        batch_size (int): Number of members in each batch
        member_args (iterable): Parameters to pass to `get_member`

    Returns:
        batches (list): A series of batches from `get_member`
    """
    def batch(*args):
        return series(get_member, batch_size, *args)
    batches = series(batch, batches, *member_args)
    return batches
